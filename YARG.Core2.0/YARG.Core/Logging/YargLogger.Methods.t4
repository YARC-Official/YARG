<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Runtime.CompilerServices;

<#
const int maxGenericArguments = 10;

var genericArguments = new string[maxGenericArguments];
var functionSignatures = new string[maxGenericArguments];
var functionParameters = new string[maxGenericArguments];
var functionArguments = new string[maxGenericArguments];

for (int i = 1; i <= maxGenericArguments; i++)
{
    genericArguments[i - 1] = "T" + i;
    functionSignatures[i - 1] = "<" + string.Join(", ", genericArguments.Take(i)) + ">";
    functionParameters[i - 1] = string.Join(", ", genericArguments.Take(i).Select((x, j) => x + " item" + (j + 1)));
    functionArguments[i - 1] = string.Join(", ", genericArguments.Take(i).Select((x, j) => "item" + (j + 1)));
}

var logTypes = new[]
{
    "Trace",
    "Debug",
    "Info",
    "Warning",
    "Error",
    //"Exception",
    //"Failure",
};


#>
namespace YARG.Core.Logging
{
    public static partial class YargLogger
    {
<#
for(int i = 0; i < maxGenericArguments; i++)
{
        var functionSignature = functionSignatures[i];
        var functionParameter = functionParameters[i];
        var functionArgument = functionArguments[i];
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<#= functionSignature #>(LogLevel level, string format, <#= functionParameter #>, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(level < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, <#= functionArgument #>);
            AddLogItemToQueue(level, source, line, member, logItem);
        }

<#
}
foreach (var type in logTypes)
{
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Log<#= type #>(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.<#= type #> < MinimumLogLevel)
            {
                return;
            }

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.<#= type #>, source, line, member, logItem);
        }

<#
    for(int i = 0; i < maxGenericArguments; i++)
    {
        var functionSignature = functionSignatures[i];
        var functionParameter = functionParameters[i];
        var functionArgument = functionArguments[i];
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void LogFormat<#= type #><#= functionSignature #>(string format, <#= functionParameter #>, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if(LogLevel.<#= type #> < MinimumLogLevel)
            {
                return;
            }

            var logItem = FormatLogItem.MakeItem(format, <#= functionArgument #>);
            AddLogItemToQueue(LogLevel.<#= type #>, source, line, member, logItem);
        }

<#
    }
}
#>
    }
}