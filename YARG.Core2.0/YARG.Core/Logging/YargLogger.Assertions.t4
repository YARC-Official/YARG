<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Runtime.CompilerServices;

<#
const int maxGenericArguments = 10;

var genericArguments = new string[maxGenericArguments];
var functionSignatures = new string[maxGenericArguments];
var functionParameters = new string[maxGenericArguments];
var functionArguments = new string[maxGenericArguments];

for (int i = 1; i <= maxGenericArguments; i++)
{
    genericArguments[i - 1] = "T" + i;
    functionSignatures[i - 1] = "<" + string.Join(", ", genericArguments.Take(i)) + ">";
    functionParameters[i - 1] = string.Join(", ", genericArguments.Take(i).Select((x, j) => x + " item" + (j + 1)));
    functionArguments[i - 1] = string.Join(", ", genericArguments.Take(i).Select((x, j) => "item" + (j + 1)));
}
#>
namespace YARG.Core.Logging
{
    public static partial class YargLogger
    {
<#
for(int i = 0; i < maxGenericArguments; i++)
{
        var functionSignature = functionSignatures[i];
        var functionParameter = functionParameters[i];
        var functionArgument = functionArguments[i];
#>
        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AssertFormat<#= functionSignature #>(bool condition, string format, <#= functionParameter #>, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                FailFormat(format, <#= functionArgument #>, source, line, member);
        }

        [DebuggerStepThrough]
        public static void FailFormat<#= functionSignature #>(string format, <#= functionParameter #>, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = FormatLogItem.MakeItem(format, <#= functionArgument #>);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }

<#
}
#>
        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        // [CallerLineNumber] is swapped compared to everything else to prevent an ambiguous overload
        public static void Assert(bool condition, [CallerLineNumber] int line = -1, [CallerFilePath] string source = "", [CallerMemberName] string member = "", [CallerArgumentExpression(nameof(condition))] string expression = "")
        {
            if (!condition)
                FailFormat("Assertion failed: {0}", expression, source, line, member);
        }

        [DebuggerStepThrough]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Assert(bool condition, string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (!condition)
                Fail(message, source, line, member);
        }

        [DebuggerStepThrough]
        public static void Fail(string message, [CallerFilePath] string source = "", [CallerLineNumber] int line = -1, [CallerMemberName] string member = "")
        {
            if (Debugger.IsAttached)
                Debugger.Break();

            var logItem = MessageLogItem.MakeItem(message);
            AddLogItemToQueue(LogLevel.Failure, source, line, member, logItem);
        }
    }
}